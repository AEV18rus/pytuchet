# План: Личный кабинет и авторизация по паролю

## Цель
- Добавить вход через браузер по логину и паролю.
- Логин — `username` из Telegram.
- Пароль пользователь задает самостоятельно в личном кабинете.
- Сохранить совместимость с текущей авторизацией через Telegram.

## Текущая архитектура
- **Основная авторизация**: Через Telegram Mini Apps `initData`. 
- **Проверка (Backend)**: Эндпоинт `/api/auth/telegram` проверяет подпись `initData` с помощью библиотеки `@tma.js/init-data-node`. Используется `TELEGRAM_BOT_TOKEN`.
- **Идентификация (API)**: После первичной авторизации используется заголовок `x-telegram-id` или `cookie-сессия` (`auth_token`).
- **Fallback**: Предусмотрен тестовый пользователь для браузера (`telegram_id = 87654321`).
- **Хранение**: Данные пользователя кешируются в `localStorage` на клиенте.
- **Безопасность**: HMAC-SHA256 валидация данных от Telegram на стороне сервера.

## Требования
- Пользователь, вошедший через Telegram, может установить пароль.
- Вход через браузер по `username` (из Telegram) + пароль.
- Безопасное хранение паролей (bcrypt/argon2).
- Сессии: безопасные `HttpOnly` cookies.
- Единая авторизация для обеих схем (Telegram и пароль).
- Обработка пользователей без `username` в Telegram (предложить установить или использовать альтернативу).

## Архитектура решения

### База данных
- Таблица `users`: добавить поля
  - `password_hash` (строка, nullable)
  - `password_set_at` (datetime, nullable)
  - `last_login_at` (datetime, nullable)
- Хэш пароля: `bcrypt` с достаточным числом раундов (12+).

### API эндпоинты
- `POST /api/auth/set-password`
  - Требует авторизацию через Telegram (залогинен по `x-telegram-id`).
  - Валидирует новый пароль, сохраняет `password_hash`, проставляет `password_set_at`.
- `POST /api/auth/login`
  - Вход по `username` + `password`.
  - Проверяет пользователя в БД, сравнивает хэш, создает сессию (cookie).
- `POST /api/auth/logout`
  - Удаляет cookie-сессию.
- `GET /api/auth/me`
  - Возвращает профиль по cookie-сессии (браузер) или `x-telegram-id` (Telegram).

### Сессии и куки
- Cookie: `HttpOnly`, `Secure` (в продакшене), `SameSite=Lax`.
- Содержимое cookie: 
  - либо `session_id` с серверным хранилищем (просто и гибко),
  - либо подписанный JWT (минимум: `user_id`, `telegram_id`, `exp`) — аккуратно с ревокацией.
- Источник истины для доступа — сервер: Next.js Route Handlers читают cookie и/или `x-telegram-id`.

### Клиентская часть
- Страница `/login`:
  - Поля: `username`, `password`, кнопка входа.
  - Успешный вход — редирект в личный кабинет.
- Страница `/account/security`:
  - Для Telegram-авторизованных: форма установки/смены пароля.
  - Показ состояния: пароль установлен/не установлен, дата установки.
- Обновление контекста авторизации:
  - Добавить поддержку cookie-сессии в `useTelegramAuth` (определять, вошел ли пользователь через браузер).
  - Единый интерфейс `isAuthenticated`, `user`, `logout`.

### Объединение схем авторизации
- `requireAuth` на сервере:
  - Пытается сначала cookie-сессию.
  - Если нет — fallback на заголовок `x-telegram-id`.
- Админ/защищенные API:
  - Используют обновленный `requireAuth`.

## Безопасность
- Пароли: `bcrypt` (12+), запрет слабых паролей, минимальная длина (не менее 8).
- Брутфорс: rate limiting для `/api/auth/login`.
- Логирование попыток входа (уровень `info/warn/error`), без записи паролей.
- CSRF: для cookie-сессий использовать `SameSite=Lax`; критичные формы можно защитить CSRF-токеном.
- Ошибки: единообразные сообщения, без утечки деталей (например, “Неверные учетные данные”).

## UX детали и крайние случаи
- Пользователь без `username` в Telegram:
  - В `/account/security` показать предупреждение и инструкцию как установить `username` в Telegram, 
  - либо предложить альтернативное поле логина (например, `display_name` или `telegram_id` по согласованию).
- Смена пароля:
  - Требовать ввод текущего пароля при его наличии.
  - Уведомление об успешной смене.
- Логаут:
  - Кнопка в шапке/меню, очищает cookie + локальное состояние.

## Критерии приемки
- Пользователь через Telegram может установить пароль.
- Пользователь может войти через `/login` по `username` + пароль.
- После входа через браузер страницы защищенные доступны.
- Логаут очищает сессию.
- Ошибки и валидаторы работают корректно (слабые пароли отклоняются).
- Логи содержат полезную информацию без утечки секретов.

## План работ (итерации)

1) Миграции БД
- Добавить поля `password_hash`, `password_set_at`, `last_login_at`.
- Обновить слой `db.ts` для чтения/записи этих полей.

2) Серверные эндпоинты
- `POST /api/auth/set-password` (только Telegram-авторизованным).
- `POST /api/auth/login`, `POST /api/auth/logout`, `GET /api/auth/me`.
- Обновить `requireAuth` для поддержки cookie.

3) Клиентские страницы
- `/login` — форма входа.
- `/account/security` — установка/смена пароля.

4) Интеграция
- Обновить `useTelegramAuth` для корректной работы с cookie-сессией.
- Обновить защищенные API/страницы на использование обновленного `requireAuth`.

5) Безопасность и полировка
- Rate limiting, улучшение сообщений ошибок, UX для отсутствия `username`.
- Журналы событий входа/выхода.

## Оценка рисков
- Пользователи без `username` в Telegram — нужен UX/альтернатива.
- Смешение двух схем авторизации — тесты на конфликт состояний.
- Хранение сессий — обеспечить очистку/ревокацию при необходимости.

## Решения под согласование
- Способ хранения сессий: cookie + `session_id` (по умолчанию) или JWT.
- Политика паролей: минимальные требования (длина, сложность).
- Альтернативный логин для пользователей без Telegram `username`.